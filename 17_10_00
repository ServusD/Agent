from agent import Agent
import random
import math

# Important: Make sure you put your agents in the agents folder, so that the
# game runner code can find them.

class StudentAgent(Agent):        
    '''A sample implementation of a random agent in the game The Resistance'''

    def __init__(self, name='Student'):
        '''
        Initialises the agent.
        '''
        self.name = name
    
    def new_game(self, number_of_players, player_number, spy_list):
        '''
        initialises the game, informing the agent of the 
        number_of_players, the player_number (an id number for the agent in the game),
        and a list of agent indexes which are the spies, if the agent is a spy, or empty otherwise
        '''
        self.number_of_players = number_of_players
        self.player_number = player_number
        self.spy_list = spy_list
        self.verbose = False
        self.number_of_spies = math.ceil(self.number_of_players / 3)
        self.mission_successes = 0 
        self.mission_failures = 0
        self.spy_prevalance = self.number_of_spies/number_of_players
        self.last_successful_team = []
        self.small_negative_adjustment = 0.9 
        self.small_positive_adjustment = 1.3
        self.large_negative_adjustment = 0.5
        self.large_positive_adjustment = 1.5
        self.current_betrayls_required = 0
        
        if not self.is_spy():
            self.trust_list = {
            i: self.number_of_spies / (self.number_of_players - 1)  #individual likelihood of being the spy
            for i in range(self.number_of_players) 
            }
            self.trust_list[self.player_number] = 1  # Set self's trust value to 1
            
            if self.verbose:
                self.print_trust()
       
    def print_trust(self):

        role = "Resistance"
        print(f"Player Number: {self.player_number} - Role: {role}")  
        if self.trust_list:
            print("Trust:")
        for player_index, likelihood in self.trust_list.items():
            print(f"{player_index}: {likelihood:.2f}")

    def is_spy(self):
        '''
        returns True iff the agent is a spy
        '''
        return self.player_number in self.spy_list
    
    def bayesian_update(self, agent, spy_likelihood):
        
            if 0 < self.trust_list[agent] < 1: 
                prior_trust = self.trust_list[agent] #P(A)
                updated_trust = prior_trust * spy_likelihood
                updated_trust = max(0, min(updated_trust, 1))
                self.trust_list[agent] = updated_trust             

    def normalize_trust(self):
        total_trust = sum(value for value in self.trust_list.values() if 0 < value < 1)
    
        if total_trust == 0:
            return  
        
        for agent in self.trust_list:
            if 0 < self.trust_list[agent] < 1:  # Normalize only if value is between 0 and 1
                self.trust_list[agent] /= total_trust

    def propose_mission(self, team_size, betrayals_required):
        '''
        expects a team_size list of distinct agents with id between 0 (inclusive) and number_of_players (exclusive)
        to be returned. 
        betrayals_required are the number of betrayals required for the mission to fail.
        '''
        
        if self.is_spy():
            if self.mission_failures < 2: # Play it safe until victory in grasp
                chosen_spy = self.player_number
                all_agents = [i for i in range(self.number_of_players) if i not in self.spy_list]
                other_agents = random.sample(all_agents, team_size - 1)
                team = [chosen_spy] + other_agents
                return team
            else: # Choose all spies to ensure victory
                team = self.spy_list.copy()
                all_agents = [i for i in range(self.number_of_players) if i not in self.spy_list]
                remaining_slots = team_size - len(team)
                if remaining_slots > 0:
                    additional_agents = random.sample(all_agents, remaining_slots)
                    team += additional_agents    
                return team
                
        else:    
            team = self.last_successful_team.copy()
            if self.player_number not in team:
                  team.append(self.player_number)
            while len(team) < team_size:  
                sorted_trust = sorted(self.trust_list.items(), key=lambda x: x[1], reverse=True)
                for agent, trust in sorted_trust:
                    if agent != self.player_number and agent not in team:  
                        team.append(agent)
                        break  
                if len(team) >= team_size:
                    break  
            return team

    def is_risky_mission(self, mission):
        trust_values = []  # Changed to a meaningful name

        if self.verbose:
            print(f"Assessing mission: {mission}")
            print(f"Betrayals required: {self.current_betrayals_required}, Trust threshold: {self.spy_prevalance}")

        for agent in mission: 
            trust_value = self.trust_list.get(agent, 1)  # Default to 1 if agent is not in trust list
            trust_values.append(trust_value)  # Append the trust value

        trust_values.sort()

        if len(trust_values) >= self.current_betrayals_required:
            lowest_trust_values = trust_values[:self.current_betrayals_required]
        else:
            lowest_trust_values = trust_values

        # Return True if the average of the selected trust values is below the threshold, indicating a risky mission
        return (sum(lowest_trust_values) / len(lowest_trust_values)) < self.spy_prevalance
        
    def vote(self, mission, proposer, betrayals_required):
        '''
        mission is a list of agents to be sent on a mission. 
        The agents on the mission are distinct and indexed between 0 and number_of_players.
        proposer is an int between 0 and number_of_players and is the index of the player who proposed the mission.
        betrayals_required are the number of betrayals required for the mission to fail.
        The function should return True if the vote is for the mission, and False if the vote is against the mission.
        '''
        self.current_betrayals_required = betrayals_required

        if proposer == self.player_number: #not proposing a mission you are not on is suspicious behaviour 
            return True

        if self.is_spy():
            spy_count = sum(1 for agent in mission if agent in self.spy_list)
            # Spies vote for the mission if they can ensure it will pass or if they meet betrayal criteria
            return spy_count >= betrayals_required
        else:
           
            if not proposer == self.player_number: #checks if the next leader is more trustworthy
                proposer_trust = self.trust_list[proposer]
            
            for agent in mission:
                if self.trust_list.get(agent) < self.spy_prevalance*1.5:  
                    return False

                next_agent_index = (proposer + 1) % len(self.trust_list)  
                next_agent_trust = self.trust_list[next_agent_index]

                if proposer_trust < next_agent_trust:
                    return False
            
            return self.is_risky_mission(mission)

    def vote_outcome(self, mission, proposer, votes):
        '''
        mission is a list of agents to be sent on a mission. 
        The agents on the mission are distinct and indexed between 0 and number_of_players.
        proposer is an int between 0 and number_of_players and is the index of the player who proposed the mission.
        votes is a dictionary mapping player indexes to Booleans (True if they voted for the mission, False otherwise).
        No return value is required or expected.
        '''
        if not self.is_spy():
            for agent, voted_yes in enumerate(votes):  # Iterate through each agent and their vote
                if agent == proposer:
                    continue  # Skip the proposer for now, will handle separately

                if voted_yes:
                        if agent not in mission:
                            self.bayesian_update(agent, 0.9)  #very suss to approve a mission not part of
                        if self.is_risky_mission(mission):
                            self.bayesian_update(agent, 0.9)
                        else: 
                            self.bayesian_update(agent, 1.3)

                else:
                    if proposer not in mission:
                        self.bayesian_update(agent, 1.2)  #Agents who voted 'no' may appear more trustworthy if the mission is suspicious
                    if self.is_risky_mission(mission):
                        self.bayesian_update(agent, 1.4)
                    else: 
                        self.bayesian_update(agent, 0.95) 

            # Evaluate the proposer separately
            if proposer not in mission:
                self.bayesian_update(proposer, 0.6)  # Penalty for proposing a mission they aren't part of
            

            if self.verbose:
                print(f"Vote results: {votes}")

    def betray(self, mission, proposer, betrayals_required):
        '''
        mission is a list of agents to be sent on a mission. 
        The agents on the mission are distinct and indexed between 0 and number_of_players, and include this agent.
        proposer is an int between 0 and number_of_players and is the index of the player who proposed the mission.
        betrayals_required are the number of betrayals required for the mission to fail.
        The method should return True if this agent chooses to betray the mission, and False otherwise. 
        Only spies are permitted to betray the mission.
        By default, spies will betray 30% of the time. 
        '''
        return True

    def mission_outcome(self, mission, proposer, num_betrayals, mission_success):
        '''
        mission is a list of agents to be sent on a mission. 
        The agents on the mission are distinct and indexed between 0 and number_of_players.
        proposer is an int between 0 and number_of_players and is the index of the player who proposed the mission.
        num_betrayals is the number of people on the mission who betrayed the mission, 
        and mission_success is True if there were not enough betrayals to cause the mission to fail, False otherwise.
        It is not expected or required for this function to return anything.
        '''
        agents_to_evaluate = [agent for agent in mission if agent != self.player_number or self.is_spy()]

        evidence = num_betrayals/len(mission)

        if not self.is_spy():
            if mission_success: 
                self.mission_successes += 1
                self.last_successful_team = mission.copy()
                for agent in agents_to_evaluate:
                    self.bayesian_update(agent, self.large_positive_adjustment*2) 
            else:
                for agent in agents_to_evaluate: 
                    if agent != proposer:  
                        if not self.is_spy() and self.player_number in mission:
                            if len(mission) == 2:
                                if agent != self.player_number:
                                    self.trust_list[agent] = 0  # Sets trust to 0 when it is able to trivially confirm a spy
                        self.bayesian_update(agent, 0.9)
                self.bayesian_update(agent, 0.9)
                self.mission_failures += 1
           

    def round_outcome(self, rounds_complete, missions_failed):
        '''
        basic informative function, where the parameters indicate:
        rounds_complete, the number of rounds (0-5) that have been completed
        missions_failed, the number of missions (0-3) that have failed.
        '''
        #nothing to do here
        
        if not self.is_spy():
            if self.verbose:
                print(f"Rounds: {rounds_complete}, Failed Missions: {missions_failed}")
                self.print_trust()
            self.normalize_trust()
    
    def game_outcome(self, spies_win, spies):
        '''
        basic informative function, where the parameters indicate:
        spies_win, True iff the spies caused 3+ missions to fail
        spies, a list of the player indexes for the spies.
        '''
        
        if not self.is_spy():
            correct_spy_guesses = 0
            correct_res_guesses = 0
            if self.verbose:
                for agent in range(self.number_of_players):
                    trust_value = self.trust_list[agent]
                    
                    if agent in spies:
                        # Spies should have low trust values if correctly identified
                        if trust_value < 0.5:
                            print(f"Agent {agent} was correctly identified as a spy by {self.player_number}")
                            correct_spy_guesses += 1
                        else:
                            print(f"Agent {agent} was trusted too much by {self.player_number}")
                    else:
                        # Loyalists should have high trust values if correctly identified
                        if trust_value >= 0.5:
                            print(f"Agent {agent} was correctly identified as loyal by {self.player_number}")
                            correct_res_guesses += 1
                        else:
                            print(f"Agent {agent} was mistakenly distrusted by {self.player_number}")

                spy_identification_accuracy = correct_spy_guesses/len(spies)
                res_identification_accuracy = correct_res_guesses/(self.number_of_players-len(spies))
                print(f"Spy Accuracy: {spy_identification_accuracy} Res Accuracy: {res_identification_accuracy}")
