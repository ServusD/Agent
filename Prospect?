from agent import Agent
import random
import math

# Important: Make sure you put your agents in the agents folder, so that the
# game runner code can find them.

class StudentAgent(Agent):        
    '''A sample implementation of a random agent in the game The Resistance'''

    def __init__(self, name='Student'):
        '''
        Initialises the agent.
        '''
        self.name = name
    
    def new_game(self, number_of_players, player_number, spy_list):
        '''
        initialises the game, informing the agent of the 
        number_of_players, the player_number (an id number for the agent in the game),
        and a list of agent indexes which are the spies, if the agent is a spy, or empty otherwise
        '''
        self.number_of_players = number_of_players
        self.player_number = player_number
        self.spy_list = spy_list
        self.verbose = False
        self.number_of_spies = math.ceil(self.number_of_players / 3)
        self.mission_successes = 0
        self.mission_failures = 0
        self.spy_prevalance = self.number_of_spies/number_of_players
        self.last_successful_team = []
        
        if not self.is_spy():
            self.trust_list = {
            i: self.number_of_spies / (self.number_of_players - 1)  # Use -1 to account for self
            for i in range(self.number_of_players) 
            }
            self.trust_list[self.player_number] = 1  # Set self's trust value to 1
            if self.verbose:
                        self.print_trust()
       

    def print_trust(self):

        role = "Spy" if self.is_spy() else "Resistance"
        print(f"Player Number: {self.player_number} - Role: {role}")  
        if self.trust_list:
            print("Trust:")
        for player_index, likelihood in self.trust_list.items():
            print(f"{player_index}: {likelihood:.2f}")

    def is_spy(self):
        '''
        returns True iff the agent is a spy
        '''
        return self.player_number in self.spy_list
    
    def bayesian_update(self, agent, spy_likelihood):
        if agent in self.trust_list:
            if 0 < self.trust_list[agent] < 1:  # Only update if value is between 0 and 1
                prior_trust = self.trust_list[agent]
                updated_trust = prior_trust * spy_likelihood
                updated_trust = max(0, min(updated_trust, 1))
                self.trust_list[agent] = updated_trust
        
        self.normalize_trust()  # Normalize after updating trust values 
        

    def normalize_trust(self):
    # Calculate total trust for values between 0 and 100
        total_trust = sum(value for value in self.trust_list.values() if 0 < value < 1)
    
        # Avoid division by zero
        if total_trust == 0:
            return  # If all values are zero or normalized, no need to normalize

        # Normalize trust values
        for agent in self.trust_list:
            if 0 < self.trust_list[agent] < 1:  # Normalize only if value is between 0 and 1
                self.trust_list[agent] /= total_trust

    def propose_mission(self, team_size, betrayals_required):
        '''
        expects a team_size list of distinct agents with id between 0 (inclusive) and number_of_players (exclusive)
        to be returned. 
        betrayals_required are the number of betrayals required for the mission to fail.
        '''
        
        if self.is_spy():
            if self.mission_failures < 2: # Play it safe until victory in grasp
                chosen_spy = self.player_number
                all_agents = [i for i in range(self.number_of_players) if i not in self.spy_list]
                other_agents = random.sample(all_agents, team_size - 1)
                team = [chosen_spy] + other_agents
                return team
            else: # Choose all spies to ensure victory
                team = self.spy_list.copy()
                all_agents = [i for i in range(self.number_of_players) if i not in self.spy_list]
                remaining_slots = team_size - len(team)
                if remaining_slots > 0:
                    additional_agents = random.sample(all_agents, remaining_slots)
                    team += additional_agents
    
                return team
                
        else:    
            team = self.last_successful_team.copy()  
            while len(team) < team_size:  
                sorted_trust = sorted(self.trust_list.items(), key=lambda x: x[1], reverse=True)
                for agent, trust in sorted_trust:
                    if agent != self.player_number and agent not in team:  
                        team.append(agent)
                        break  
                if len(team) >= team_size:
                    break  
            return team

    def mission_risk_factor(self, mission, betrayals_required, trust_threshold):
        lowest_trust = 1 

        if self.verbose:
            print(f"Assessing mission: {mission}")
            print(f"Betrayals required: {betrayals_required}, Trust threshold: {trust_threshold}")

        for agent in mission:
            if agent != self.player_number:  
                trust_value = self.trust_list.get(agent, 1) 
                if trust_value < lowest_trust:
                    lowest_trust = trust_value

        # Determine if the mission is too risky by comparing the lowest trust value to the threshold
        return lowest_trust < (betrayals_required * trust_threshold)
        
    def vote(self, mission, proposer, betrayals_required):
        '''
        mission is a list of agents to be sent on a mission. 
        The agents on the mission are distinct and indexed between 0 and number_of_players.
        proposer is an int between 0 and number_of_players and is the index of the player who proposed the mission.
        betrayals_required are the number of betrayals required for the mission to fail.
        The function should return True if the vote is for the mission, and False if the vote is against the mission.
        '''
        if proposer == self.player_number: #not proposing a mission you are not on is suspicious behaviour 
            return True

        if self.is_spy():
            spy_count = sum(1 for agent in mission if agent in self.spy_list)
            # Spies vote for the mission if they can ensure it will pass or if they meet betrayal criteria
            return spy_count >= betrayals_required
        else:
           
            if not proposer == self.player_number: #checks if the next leader is more trustworthy
                proposer_trust = self.trust_list[proposer]
            
            for agent in mission:
                if self.trust_list.get(agent, 1) < self.spy_prevalance:  # Default to 1 if not found
                    return False

                next_agent_index = (proposer + 1) % len(self.trust_list)  
                next_agent_trust = self.trust_list[next_agent_index]

                if proposer_trust < next_agent_trust:
                    return False
            
            return self.mission_risk_factor(mission, betrayals_required, self.spy_prevalance)

    def vote_outcome(self, mission, proposer, votes):
        '''
        mission is a list of agents to be sent on a mission. 
        The agents on the mission are distinct and indexed between 0 and number_of_players.
        proposer is an int between 0 and number_of_players and is the index of the player who proposed the mission.
        votes is a dictionary mapping player indexes to Booleans (True if they voted for the mission, False otherwise).
        No return value is required or expected.
        '''
        
        yes_votes = sum(vote for vote in votes if vote)  
        no_votes = len(votes) - yes_votes          
        vote_success = yes_votes > no_votes

        if not self.is_spy():
            if proposer not in mission:
                self.bayesian_update(proposer, 0.75)

            if vote_success:
                for agent in range(len(votes)):
                    if agent != proposer:  
                        self.bayesian_update(agent, 1.25)
                    else:
                        self.bayesian_update(agent, 1.25)
            else:            
                for agent in range(len(votes)):
                    if agent != proposer:  
                        self.bayesian_update(agent, 0.9)
                    else:
                        self.bayesian_update(agent, 0.9)

            if self.verbose:
                print(f"Vote results: {votes}, Vote success: {vote_success}")

    def betray(self, mission, proposer, betrayals_required):
        '''
        mission is a list of agents to be sent on a mission. 
        The agents on the mission are distinct and indexed between 0 and number_of_players, and include this agent.
        proposer is an int between 0 and number_of_players and is the index of the player who proposed the mission.
        betrayals_required are the number of betrayals required for the mission to fail.
        The method should return True if this agent chooses to betray the mission, and False otherwise. 
        Only spies are permitted to betray the mission.
        By default, spies will betray 30% of the time. 
        '''
        return True

    def mission_outcome(self, mission, proposer, num_betrayals, mission_success):
        '''
        mission is a list of agents to be sent on a mission. 
        The agents on the mission are distinct and indexed between 0 and number_of_players.
        proposer is an int between 0 and number_of_players and is the index of the player who proposed the mission.
        num_betrayals is the number of people on the mission who betrayed the mission, 
        and mission_success is True if there were not enough betrayals to cause the mission to fail, False otherwise.
        It is not expected or required for this function to return anything.
        '''
        agents_to_evaluate = [agent for agent in mission if agent != self.player_number or self.is_spy()]

        evidence = num_betrayals/len(mission)

        if not self.is_spy():
            if mission_success: 
                self.mission_successes += 1
                self.last_successful_team = mission.copy()
                for agent in agents_to_evaluate:
                    self.bayesian_update(agent, 1.25) 
            else:
                for agent in agents_to_evaluate: 
                    if agent != proposer:  
                        if not self.is_spy() and self.player_number in mission:
                            if len(mission) == 2:
                                if agent != self.player_number:
                                    self.trust_list[agent] = 0  # Sets trust to 0 when it is able to trivially confirm a spy
                        self.bayesian_update(agent, evidence)
                self.bayesian_update(proposer, evidence*0.75)  #greater evidence if they proposed the team
                self.mission_failures += 1
            if self.verbose:
                self.print_trust()

    def round_outcome(self, rounds_complete, missions_failed):
        '''
        basic informative function, where the parameters indicate:
        rounds_complete, the number of rounds (0-5) that have been completed
        missions_failed, the number of missions (0-3) that have failed.
        '''
        #nothing to do here
        pass
    
    def game_outcome(self, spies_win, spies):
        '''
        basic informative function, where the parameters indicate:
        spies_win, True iff the spies caused 3+ missions to fail
        spies, a list of the player indexes for the spies.
        '''
        #nothing to do here
        pass
